//---------------------------------------------------------------------------


#pragma hdrstop

#include "matrix.h"
#include "mathematic.h"

//---------------------------------------------------------------------------

#pragma package(smart_init)
//---------------------------------------------------------------------------
//процедура умножения матрицы A 3х3 на вектор r
void matr_X_vect(double A[3][3], double r[3], double r1[3]){

for(int j=0; j<3; j++){
	r1[j]=0;
	for(int i=0; i<3; i++)
		r1[j]+=A[j][i]*r[i];
}
}
//---------------------------------------------------------------------------
//процедура умножения матрицы A 3х3 на матрицу 3х3 B
void matr_X_matr(double A[3][3], double B[3][3], double C[3][3]){
for(int k=0; k<3; k++)
for(int j=0; j<3; j++){
	C[k][j]=0;
	for(int i=0; i<3; i++)
		C[k][j]+=A[k][i]*B[i][j];
}
}
//---------------------------------------------------------------------------
//процедура транспонирования матрицы А 3х3
void matr_T(const double A[3][3], double B[3][3]){
for(int i=0; i<3; i++) {
	for(int j=0; j<3; j++)
		B[i][j]=A[j][i];
}
}
//---------------------------------------------------------------------------
//процедура преобразование матрицы в кватернион
void MatrToQ(const double a[3][3], double q[4]){
double zn;
q[0]=0.5*sqrt(1.+a[0][0]+a[1][1]+a[2][2]);
zn=q[0]*4;
zn=1./zn;
q[1]=(a[1][2]-a[2][1])*zn;
q[2]=(a[2][0]-a[0][2])*zn;
q[3]=(a[0][1]-a[1][0])*zn;
}
//---------------------------------------------------------------------------
//процедура преобразования кватерниона в матрицу
void QToMatr(const double q[4], double a[3][3]){

a[0][0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3];
a[1][0]=2*(-q[0]*q[3]+q[1]*q[2]);
a[2][0]=2*(q[0]*q[2]+q[1]*q[3]);

a[0][1]=2*(q[0]*q[3]+q[1]*q[2]);
a[1][1]=q[0]*q[0]+q[2]*q[2]-q[1]*q[1]-q[3]*q[3];
a[2][1]=2*(-q[0]*q[1]+q[2]*q[3]);

a[0][2]=2*(-q[0]*q[2]+q[1]*q[3]);
a[1][2]=2*(q[0]*q[1]+q[2]*q[3]);
a[2][2]=q[0]*q[0]+q[3]*q[3]-q[1]*q[1]-q[2]*q[2];
}

//Определение матрицы поворота вокруг одной из осей СК на заданный угол
void RotMat(int i, double a, double A[3][3])
//
// j - признак оси поворота:    0 - x
//                              1 - y
//                              2 - z
// Alpha - угол поворота (рад)

{

double cA = cos(a), sA = sin(a);

switch(i){
	case 0: A[0][0] = 1;  A[0][1] = 0;   A[0][2] = 0;
			A[1][0] = 0;  A[1][1] = cA;  A[1][2] = sA;
			A[2][0] = 0;  A[2][1] =-sA;  A[2][2] = cA;
			break;
	case 1: A[0][0] = cA;  A[0][1] = 0;  A[0][2] =-sA;
			A[1][0] = 0;   A[1][1] = 1;  A[1][2] = 0;
			A[2][0] = sA;  A[2][1] = 0;  A[2][2] = cA;
			break;
	case 2: A[0][0] = cA;  A[0][1] = sA; A[0][2] = 0;
			A[1][0] =-sA;  A[1][1] = cA; A[1][2] = 0;
			A[2][0] = 0;   A[2][1] = 0;  A[2][2] = 1;
			break;

}

}
