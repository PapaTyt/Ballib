//---------------------------------------------------------------------------


#pragma hdrstop

#include "matrix.h"
#include "mathematic.h"
#include "report.h"

//---------------------------------------------------------------------------

#pragma package(smart_init)
//---------------------------------------------------------------------------
//процедура умножения матрицы A 3х3 на вектор r
void matr_X_vect(double A[3][3], double r[3], double r1[3]){

for(int j=0; j<3; j++){
	r1[j]=0;
	for(int i=0; i<3; i++)
		r1[j]+=A[j][i]*r[i];
}
}
//---------------------------------------------------------------------------
//процедура умножения матрицы A 3х3 на матрицу 3х3 B
void matr_X_matr(double A[3][3], double B[3][3], double C[3][3]){
for(int k=0; k<3; k++)
for(int j=0; j<3; j++){
	C[k][j]=0;
	for(int i=0; i<3; i++)
		C[k][j]+=A[k][i]*B[i][j];
}
}
//---------------------------------------------------------------------------
//процедура транспонирования матрицы А 3х3
void matr_T(const double A[3][3], double B[3][3]){
for(int i=0; i<3; i++) {
	for(int j=0; j<3; j++)
		B[i][j]=A[j][i];
}
}
//---------------------------------------------------------------------------
//процедура преобразование матрицы в кватернион
void MatrToQ(const double a[3][3], double q[4]){
double zn;
q[0]=0.5*sqrt(1.+a[0][0]+a[1][1]+a[2][2]);
zn=q[0]*4;
if(zn==0) report(3);
zn=1./zn;
q[1]=(a[1][2]-a[2][1])*zn;
q[2]=(a[2][0]-a[0][2])*zn;
q[3]=(a[0][1]-a[1][0])*zn;
}
//---------------------------------------------------------------------------
//процедура преобразования кватерниона в матрицу
void QToMatr(const double q[4], double a[3][3]){

a[0][0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3];
a[1][0]=2*(-q[0]*q[3]+q[1]*q[2]);
a[2][0]=2*(q[0]*q[2]+q[1]*q[3]);

a[0][1]=2*(q[0]*q[3]+q[1]*q[2]);
a[1][1]=q[0]*q[0]+q[2]*q[2]-q[1]*q[1]-q[3]*q[3];
a[2][1]=2*(-q[0]*q[1]+q[2]*q[3]);

a[0][2]=2*(-q[0]*q[2]+q[1]*q[3]);
a[1][2]=2*(q[0]*q[1]+q[2]*q[3]);
a[2][2]=q[0]*q[0]+q[3]*q[3]-q[1]*q[1]-q[2]*q[2];
}

//Определение матрицы поворота вокруг одной из осей СК на заданный угол
void RotMat(int i, double a, double A[3][3])
//
// i - признак оси поворота:    0 - x
//                              1 - y
//                              2 - z
// a - угол поворота (рад)

{

double cA = cos(a), sA = sin(a);

switch(i){
	case 0:  A[0][0] = 1;  A[0][1] = 0;   A[0][2] = 0;
			 A[1][0] = 0;  A[1][1] = cA;  A[1][2] = sA;
			 A[2][0] = 0;  A[2][1] =-sA;  A[2][2] = cA;
			 break;
	case 1:  A[0][0] = cA;  A[0][1] = 0;  A[0][2] =-sA;
			 A[1][0] = 0;   A[1][1] = 1;  A[1][2] = 0;
			 A[2][0] = sA;  A[2][1] = 0;  A[2][2] = cA;
			 break;
	case 2:  A[0][0] = cA;  A[0][1] = sA; A[0][2] = 0;
			 A[1][0] =-sA;  A[1][1] = cA; A[1][2] = 0;
			 A[2][0] = 0;   A[2][1] = 0;  A[2][2] = 1;
			 break;
	default: A[0][0] = 1;  A[0][1] = 0; A[0][2] = 0;
			 A[1][0] = 0;  A[1][1] = 1; A[1][2] = 0;
			 A[2][0] = 0;  A[2][1] = 0; A[2][2] = 1;
			 report(4);
		     break;

}

}

   //матрицы 6х6
//---------------------------------------------------------------------------
//процедура обнулени¤ 6-ти мерного вектора
void vect_zero(double X[6]){
for(int i=0; i<6; i++)
X[i]=0;
}
//---------------------------------------------------------------------------
//процедура записи вектора Х в вектор Y
void vect_copy(double X[6], double Y[6]){
for(int i=0; i<6; i++)
Y[i]=X[i];
}
//---------------------------------------------------------------------------
//вычитание из 6-ти мерного вектора 6-ти мерного вектора
void vect_minus(double X[6], double Y[6], double Z[6]){
for(int i=0; i<6; i++)
Z[i]=X[i]-Y[i];
}
//---------------------------------------------------------------------------
//вычитание из 6-ти мерного вектора 6-ти мерного вектора
void vect_minus(double X[6], double Y[6]){
for(int i=0; i<6; i++)
X[i]=X[i]-Y[i];
}
//---------------------------------------------------------------------------
//сложение 6-ти мерного вектора с 6-ти мерным вектором
void vect_add(double X[6], double Y[6], double Z[6]){
for(int i=0; i<6; i++)
Z[i]=X[i]+Y[i];
}
//---------------------------------------------------------------------------
//сложение 6-ти мерного вектора с 6-ти мерным вектором
void vect_add(double X[6], double Y[6]){
for(int i=0; i<6; i++)
X[i]=X[i]+Y[i];
}
//---------------------------------------------------------------------------
//умножение вектора на число
void vect_x_n(double X[6], double n, double Y[6]){
for(int i=0; i<6; i++)
Y[i]=X[i]*n;
}
//---------------------------------------------------------------------------
//умножение вектора на число
void vect_x_n(double X[6], double n){
for(int i=0; i<6; i++)
X[i]=X[i]*n;
}
//---------------------------------------------------------------------------
//процедура обнуления матрицы 6х6
void matr_zero(double A[6][6]){
for(int i=0; i<6; i++)
for(int j=0; j<6; j++)
	A[i][j]=0;
}
//---------------------------------------------------------------------------
//процедура записи матрицы А 6х6 в матрицу В 6х6
void matr_copy(double A[6][6], double B[6][6]){
for(int i=0; i<6; i++)
for(int j=0; j<6; j++)
	B[i][j]=A[i][j];
}
//---------------------------------------------------------------------------
//вычитание матрицы 6х6 из матрицы 6х6
void matr_minus(double A[6][6], double B[6][6], double C[6][6]){
for(int i=0; i<6; i++)
for(int j=0; j<6; j++)
	C[i][j]=A[i][j]-B[i][j];
}
//---------------------------------------------------------------------------
//вычитание матрицы 6х6 из матрицы 6х6
void matr_minus(double A[6][6], double B[6][6]){
for(int i=0; i<6; i++)
for(int j=0; j<6; j++)
	A[i][j]-=B[i][j];
}
//---------------------------------------------------------------------------
//сложение матрицы 6х6 с матрицей 6х6
void matr_add(double A[6][6], double B[6][6], double C[6][6]){
for(int i=0; i<6; i++)
for(int j=0; j<6; j++)
	C[i][j]=A[i][j]+B[i][j];
}
//---------------------------------------------------------------------------
//сложение матрицы 6х6 с матрицей 6х6
void matr_add(double A[6][6], double B[6][6]){
for(int i=0; i<6; i++)
for(int j=0; j<6; j++)
	A[i][j]+=B[i][j];
}
//---------------------------------------------------------------------------
//умножение матрицы 6х6 на число
void matr_X_n(double A[6][6], double n, double B[6][6]){
for(int i=0; i<3; i++)
for(int j=0; j<3; j++)
	B[i][j]=A[i][j]*n;
}//---------------------------------------------------------------------------
//умножение матрицы 6х6 на число
void matr_X_n(double A[6][6], double n){
for(int i=0; i<3; i++)
for(int j=0; j<3; j++)
	A[i][j]*=n;
}
//---------------------------------------------------------------------------
//процедура умножение матрицы A 6х6 на вектор X 6х1
void matr_X_vect(double A[6][6], double X[6], double Y[6]){

for(int j=0; j<6; j++){
	Y[j]=0;
	for(int i=0; i<6; i++)
		Y[j]+=A[j][i]*X[i];
}
}
//процедура умножение вектор X 1х6 на матрицу A 6х6
void vect_X_matr(double X[6], double A[6][6], double Y[6]){

for(int j=0; j<6; j++){
	Y[j]=0;
	for(int i=0; i<6; i++)
		Y[j]+=X[i]*A[i][j];
}
}
//---------------------------------------------------------------------------
//процедура умножени¤ матрицы A 6х6 на матрицу B 6х6
void matr_X_matr(double A[6][6], double B[6][6], double C[6][6]){
for(int k=0; k<6; k++)
for(int j=0; j<6; j++){
	C[k][j]=0;
	for(int i=0; i<6; i++)
		C[k][j]+=A[k][i]*B[i][j];
}
}
//---------------------------------------------------------------------------
//процедура умножени¤ матрицы A 6х6 на матрицу B 6х6
void matr_X_matr(double A[6][6], double B[6][6]){
double C[6][6]={0};

for(int k=0; k<6; k++)
for(int j=0; j<6; j++){
	C[k][j]=0;
	for(int i=0; i<6; i++)
		C[k][j]+=A[k][i]*B[i][j];
}
matr_copy(C,A);
}
//---------------------------------------------------------------------------
//процедура транспонировани¤ матрицы A 6х6
void matr_T(double A[6][6], double B[6][6]){
for(int i=0; i<6; i++) {
	for(int j=0; j<6; j++)
		B[i][j]=A[j][i];
}
}
//---------------------------------------------------------------------------
//процедура транспонировани¤ матрицы A 6х6
void matr_T(double A[6][6]){
double B[6][6];
for(int i=0; i<6; i++) {
	for(int j=0; j<6; j++)
		B[i][j]=A[j][i];
}
matr_copy(B,A);
}
//---------------------------------------------------------------------------
//обращение матрицы 6x6
void inversion(double A[6][6])
{   int N=6;
	double temp;
	double E[6][6]={0};

    for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++){
			E[i][j] = 0.0;
			if (i == j)
                E[i][j] = 1.0;
		}
	for (int k = 0; k < N; k++){
		temp = A[k][k];
		if(temp==0) report(5);
		for (int j = 0; j < N; j++){
			A[k][j] /= temp;
            E[k][j] /= temp;
		}
		for (int i = k + 1; i < N; i++){
			temp = A[i][k];
			for (int j = 0; j < N; j++){
                A[i][j] -= A[k][j] * temp;
                E[i][j] -= E[k][j] * temp;
            }
        }
	}
	for (int k = N - 1; k > 0; k--){
		for (int i = k - 1; i >= 0; i--){
			temp = A[i][k];
			for (int j = 0; j < N; j++){
                A[i][j] -= A[k][j] * temp;
                E[i][j] -= E[k][j] * temp;
            }
        }
    }
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
			A[i][j] = E[i][j];

}

//класс матрицы
//---------------------------------------------------------------------------
//процедура инициализации матрицы nxm
void matrix::create_A(int n_, int m_){
std::vector<double> tmp;
n=n_;
m=m_;
A.clear();
for(int i=0; i<m; i++) tmp.push_back(0.0);
for(int i=0; i<n; i++) A.push_back(0.0);
}
//---------------------------------------------------------------------------
//процедура инициализации вектора столбца
void matrix::create_X(int n_){
n=n_;
m=1;
X.clear();
for(int i=0; i<n; i++) X.push_back(0.0);
}
//---------------------------------------------------------------------------
//процедура инициализации вектора строки
void matrix::create_Y(int m_){
n=1;
m=m_;
Y.clear();
for(int i=0; i<m; i++) Y.push_back(0.0);
}
//---------------------------------------------------------------------------
//процедура обнуления матрицы nxm
void matrix::zero_A(){
for(int i=0; i<n; i++)
	for(int j=0; j<m; j++)
		A[i][j]=0.0;
}
//---------------------------------------------------------------------------
//процедура обнуления вектора столбца
void matrix::zero_X(){
for(int i=0; i<X.size(); i++)

		X[i]=0.0;
}
//---------------------------------------------------------------------------
//процедура обнуления вектора строки
void matrix::zero_Y(){
for(int i=0; i<Y.size(); i++)
		Y[i]=0.0;
}
//---------------------------------------------------------------------------
//процедура инициализации диагональной матрицы
void matrix::diagonal_matrix(){
for(int i=0; i<n; i++)
	for(int j=0; j<m; j++)
		if(i==j) A[i][j]=1.0;
		else A[i][j]=0.0;
}
//---------------------------------------------------------------------------
//процедура инициализации единичной матрицы
void matrix::identity_matrix(){
for(int i=0; i<n; i++)
	for(int j=0; j<m; j++)
		A[i][j]=1.0;
}
//---------------------------------------------------------------------------
//процедура сложения матриц A=A+B.A
void matrix::add_A(matrix B){
	if(n==B.n && m=B.m){
		for(int i=0; i<n; i++)
			for(int j=0; j<m; j++)
				A[i][j]+=B.A[i][j];		
	}
	else {
		report(6);
	}
}
//---------------------------------------------------------------------------
//процедура сложения векторов столбцов X=X+B.X
void matrix::add_X(matrix B){
	if(n==B.n && B.m==1){
		for(int i=0; i<n; i++)
			X[i]+=B.X[i];		
	}
	else {
		report(7);
	}
}
//---------------------------------------------------------------------------
//процедура сложения векторов столбцов Y=Y+B.Y
void matrix::add_Y(matrix B){
	if(B.n==1 && m==B.m){
		for(int i=0; i<m; i++)
			Y[i]+=B.Y[i];		
	}
	else {
		report(8);
	}
}
//---------------------------------------------------------------------------
//процедура вычитания матриц A=A-B.A
void matrix::minus_A(matrix B){
	if(n==B.n && m=B.m){
		for(int i=0; i<n; i++)
			for(int j=0; j<m; j++)
				A[i][j]-=B.A[i][j];		
	}
	else {
		report(9);
	}
}
//---------------------------------------------------------------------------
//процедура вычитания векторов столбцов X=X-B.X
void matrix::minus_X(matrix B){
	if(n==B.n && B.m==1){
		for(int i=0; i<n; i++)
			X[i]-=B.X[i];		
	}
	else {
		report(10);
	}
}
//---------------------------------------------------------------------------
//процедура вычитания векторов столбцов Y=Y-B.Y
void matrix::minus_Y(matrix B){
	if(B.n==1 && m==B.m){
		for(int i=0; i<m; i++)
			Y[i]-=B.Y[i];		
	}
	else {
		report(11);
	}
}
//---------------------------------------------------------------------------
//процедура умножения матрицы на число A=k*A
void matrix::multiplication_A(double k){
	for(int i=0; i<n; i++)
		for(int j=0; j<m; j++)
			A[i][j]=k*A[i][j];		
}
//---------------------------------------------------------------------------
//процедура вычитания векторов столбцов X=k*X
void matrix::multiplication_X(double k){
	for(int i=0; i<n; i++)
		X[i]=k*X[i];		
}
//---------------------------------------------------------------------------
//процедура вычитания векторов столбцов Y=k*Y
void matrix::multiplication_Y(double k){
	for(int i=0; i<m; i++)
		Y[i]=k*Y[i];		
}
//---------------------------------------------------------------------------
//процедура транспонирования матрицы A=A^T
void matrix::transposition_A(){
std::vector< std::vector<double> > B;
std::vector<double> temp;

	for(int i=0; i<n; i++){
		temp.clear();
		for(int j=0; j<m; j++) {
			temp.push_back(A[j][i]);
		}
	B.push_back(temp);
	}
int k=m;
m=n;
n=k;
}
//---------------------------------------------------------------------------
//процедура транспонирования  векторов столбцов Y=X^T
void matrix::transposition_X(){
	Y.clear();
	for(int i=0; i<n; i++)
		Y[i]=X[i];	
	m=n;
	n=1;
}
//---------------------------------------------------------------------------
//процедура транспонирования  векторов столбцов X=Y^T
void matrix::transposition_Y(){
	X.clear();
	for(int i=0; i<m; i++)
		X.push_back(Y[i]);
	n=m;
	m=1;
}
//---------------------------------------------------------------------------
//процедура умножения матрицы на матрицу слева A=B*A
void matrix::left_multiplication(matrix B){

std::vector< std::vector<double> > C;
std::vector<double> temp;
double f;
if(n==B.m){
	C.clear();
	for(int k=0; k<B.n; k++){
		temp.clear();

		for(int j=0; j<m; j++){
			f=0;
			for(int i=0; i<n; i++)
				f+=A[k][i]*B.A[i][j];
			temp.push_back(f);
		}
		C.push_back(temp);
	}
	A=C;		
}
else{
	report(12);
}
}
//---------------------------------------------------------------------------
//процедура умножения матрицы на матрицу справа A=A*B
void matrix::right_multiplication(matrix B){

std::vector< std::vector<double> > C;
std::vector<double> temp;
double f;
if(m==B.n){
	C.clear();
	for(int k=0; k<n; k++){
		temp.clear();

		for(int j=0; j<B.m; j++){
			f=0;
			for(int i=0; i<B.n; i++)
				f+=A[k][i]*B.A[i][j];
			temp.push_back(f);
		}
		C.push_back(temp);
	}
	A=C;		
}
else{
	report(13);
}
}
//---------------------------------------------------------------------------
//процедура умножения матрицы на вектор столбец A=A*X
void matrix::multiplication_X(matrix B){

double f;
if(m==B.n){
	X.clear();
	for(int k=0; k<n; k++){
		f=0;
		for(int i=0; i<B.n; i++)
			f+=A[k][i]*B.X[i];
		X.push_back(f);
		}
	}
else{
	report(14);
}
}
//---------------------------------------------------------------------------
//процедура умножения матрицы на вектор строку A=Y*A
void matrix::multiplication_Y(matrix B){

double f;
if(B.m==n){
	Y.clear();
	for(int k=0; k<B.m; k++){
		f=0;
		for(int i=0; i<n; i++)
			f=B.Y[i]*A[i][k];

		Y.push_back(f);
		}
	}
else{
	report(15);
}
}


