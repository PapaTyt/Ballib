//---------------------------------------------------------------------------


#pragma hdrstop
#include <math.h>
#include "kepler.h"
#include "constants.h"

//---------------------------------------------------------------------------

#pragma package(smart_init)

//Нахождение декартовых координат по элементам орбиты
void ElemToCoord_ypr (const double &a, const double &e, const double &u,
					  const double &i, const double &omega, const double & OMEGA,
					  double &x, double &y, double &z){
		//перевод елементов орбиты в декартовы координаты
		double Px, Py, Pz, r;
		Px = cos(u)*cos(OMEGA) - sin(u)*sin(OMEGA)*cos(i);
		Py = cos(u)*sin(OMEGA) + sin(u)*cos(OMEGA)*cos(i);
		Pz = sin(u)*sin(i);
		r = a*(1 - e*e)/(1 + e*cos(u - omega));
		x = r*Px;
		y = r*Py;
		z = r*Pz;
}
//---------------------------------------------------------------------------
/*Процедура перевода элементов орбиты в вектор состояния
Входные параметры:
		Ar1[6] - массив элементов орбиты
				Ar1[0] = a
				Ar1[1] = e
				Ar1[2] = u
				Ar1[3] = i
				Ar1[4] = omega
				Ar1[5] = OMEGA
Выходные параметры:
		Ar2[6] - радиус-вектор (x, y, z) [км] и вектор скорости (vx, vy, vz) [км/с]
Подключаемые модули:
		<math.h>
		"constants.h"
*/
void ElemToCoord(double Ar1[], double Ar2[]){
     double a1, b1, g1, a2, b2, g2, tet, r, C, p;
	 p = Ar1[0]*(1 - Ar1[1]*Ar1[1]);
     a1 = cos(Ar1[2])*cos(Ar1[5]) - sin(Ar1[2])*sin(Ar1[5])*cos(Ar1[3]);      //
	 b1 = cos(Ar1[2])*sin(Ar1[5]) + sin(Ar1[2])*cos(Ar1[5])*cos(Ar1[3]);      // направляющие косинусы вектора r
     g1 = sin(Ar1[2])*sin(Ar1[3]);                                            //
     a2 = - (sin(Ar1[2])*cos(Ar1[5]) + cos(Ar1[2])*sin(Ar1[5])*cos(Ar1[3]));  //
	 b2 = cos(Ar1[2])*cos(Ar1[5])*cos(Ar1[3]) - sin(Ar1[2])*sin(Ar1[5]);      // направляющие косинусы нормали к вект r
	 g2 = cos(Ar1[2])*sin(Ar1[3]);                                            //
     tet = Ar1[2] - Ar1[4];
     C = sqrt(p*mu);
     r = p/(1 + Ar1[1]*cos(tet));
	 Ar2[0] = r*a1;                                                   // X
     Ar2[1] = r*b1;                                                   // Y
     Ar2[2] = r*g1;                                                   // Z
     Ar2[3] = C*(a1*Ar1[1]*sin(tet) + a2*(1 + Ar1[1]*cos(tet)))/p;    // Vx
	 Ar2[4] = C*(b1*Ar1[1]*sin(tet) + b2*(1 + Ar1[1]*cos(tet)))/p;    // Vy
	 Ar2[5] = C*(g1*Ar1[1]*sin(tet) + g2*(1 + Ar1[1]*cos(tet)))/p;    // Vz
  }
  //---------------------------------------------------------------------------
/*Процедура перевода элементов орбиты в вектор состояния
Входные параметры:
		Ar1[6] - массив элементов орбиты
				Ar1[0] = a
				Ar1[1] = e
				Ar1[2] = u
				Ar1[3] = i
				Ar1[4] = omega
				Ar1[5] = OMEGA
Выходные параметры:
		r1[3] - радиус-вектор (x, y, z) [км]
		v1[3] - вектор скорости (vx, vy, vz) [км/с]
Подключаемые модули:
		<math.h>
		"constants.h"
*/
void ElemToCoord(double Ar1[], double r1[], double v1[]){
	 double a1, b1, g1, a2, b2, g2, tet, r, C, p;
	 p = Ar1[0]*(1 - Ar1[1]*Ar1[1]);
	 a1 = cos(Ar1[2])*cos(Ar1[5]) - sin(Ar1[2])*sin(Ar1[5])*cos(Ar1[3]);      //
	 b1 = cos(Ar1[2])*sin(Ar1[5]) + sin(Ar1[2])*cos(Ar1[5])*cos(Ar1[3]);      // направляющие косинусы вектора r
	 g1 = sin(Ar1[2])*sin(Ar1[3]);                                            //
	 a2 = - (sin(Ar1[2])*cos(Ar1[5]) + cos(Ar1[2])*sin(Ar1[5])*cos(Ar1[3]));  //
	 b2 = cos(Ar1[2])*cos(Ar1[5])*cos(Ar1[3]) - sin(Ar1[2])*sin(Ar1[5]);      // направляющие косинусы нормали к вект r
	 g2 = cos(Ar1[2])*sin(Ar1[3]);                                            //
	 tet = Ar1[2] - Ar1[4];
	 C = sqrt(p*mu);
	 r = p/(1 + Ar1[1]*cos(tet));
	 r1[0] = r*a1;                                                   // X
	 r1[1] = r*b1;                                                   // Y
	 r1[2] = r*g1;                                                   // Z
	 v1[0] = C*(a1*Ar1[1]*sin(tet) + a2*(1 + Ar1[1]*cos(tet)))/p;    // Vx
	 v1[1] = C*(b1*Ar1[1]*sin(tet) + b2*(1 + Ar1[1]*cos(tet)))/p;    // Vy
	 v1[2] = C*(g1*Ar1[1]*sin(tet) + g2*(1 + Ar1[1]*cos(tet)))/p;    // Vz
  }

//---------------------------------------------------------------------------
/*Процедура перевода вектора состояния в элементы орбиты
Входные параметры:
		Ar1[6] - радиус-вектор (x, y, z) [км] и вектор скорости (vx, vy, vz) [км/с]

Выходные параметры:
		Ar2[6] - массив элементов орбиты
				Ar2[0] = a
				Ar2[1] = e
				Ar2[2] = u
				Ar2[3] = i
				Ar2[4] = omega
				Ar2[5] = OMEGA
Подключаемые модули:
		<math.h>
		"constants.h"
*/
void CoordToElem(double Ar1[], double Ar2[])
  {
     double r, V, C, C1, C2, C3, f, f1, f2, f3, p;
	 r = sqrt(Ar1[0]*Ar1[0] + Ar1[1]*Ar1[1] + Ar1[2]*Ar1[2]); // модуль в-ра r
  //  V = sqrt(Ar1[3]*Ar1[3] + Ar1[4]*Ar1[4] * Ar1[5]*Ar1[5]); // модуль в-ра V
  // возможно нужен поиск угла между этими векторами Альфа
  // находим компоненты и модули вектора кинетического момента C и в-ра Лапласа f
     C1 = Ar1[1]*Ar1[5] - Ar1[2]*Ar1[4];
	 C2 = Ar1[2]*Ar1[3] - Ar1[0]*Ar1[5];
	 C3 = Ar1[0]*Ar1[4] - Ar1[1]*Ar1[3];
     C = sqrt(C1*C1 + C2*C2 + C3*C3);
	 f1 = -mu*Ar1[0]/r + C3*Ar1[4] - C2*Ar1[5];
	 f2 = -mu*Ar1[1]/r + C1*Ar1[5] - C3*Ar1[3];
	 f3 = -mu*Ar1[2]/r + C2*Ar1[3] - C1*Ar1[4];
	 f = sqrt(f1*f1 + f2*f2 + f3*f3);
	 Ar2[1] = f/mu;                    // эксцентриситет е
	 p = (C*C)/mu;                     // фокальный параметр р
	 Ar2[0] = p/(1 - Ar2[1]*Ar2[1]);   // большая полуось орбиты a
	 Ar2[3] = acos(C3/C);              // наклонение i [0;pi]

  // находим омегуБ, омегуМ, и u в диапазоне [0;2pi] сравнивая син и кос
	 double AC, AS;
  // Ar2[5] = ОмегаБ
	 AS = C1/(C*sin(Ar2[3]));
	 AC = - C2/(C*sin(Ar2[3]));

	 Ar2[5] = atan2(AS,AC);
  //----------------
  // Ar2[4] = ОмегаМ
	 AS = (-f1*sin(Ar2[5]) + f2*cos(Ar2[5]))/(f*cos(Ar2[3]));
	 AC = (f1*cos(Ar2[5]) + f2*sin(Ar2[5]))/f;
	 Ar2[4] = atan2(AS,AC);
  //----------------
  // Ar2[2] = угол u
	 AS = (-Ar1[0]*sin(Ar2[5]) + Ar1[1]*cos(Ar2[5]))/(r*cos(Ar2[3]));
	 AC = (Ar1[0]*cos(Ar2[5]) + Ar1[1]*sin(Ar2[5]))/r;

	 Ar2[2] = atan2(AS,AC);
  }
  //---------------------------------------------------------------------------
/*Процедура перевода вектора состояния в элементы орбиты
Входные параметры:
		r1[3] - радиус-вектор (x, y, z) [км]
		v1[3] - вектор скорости (vx, vy, vz) [км/с]

Выходные параметры:
		Ar2[6] - массив элементов орбиты
				Ar2[0] = a
				Ar2[1] = e
				Ar2[2] = u
				Ar2[3] = i
				Ar2[4] = omega
				Ar2[5] = OMEGA
Подключаемые модули:
		<math.h>
		"constants.h"
*/
void CoordToElem(double r1[], double v1[], double Ar2[]){
	 double Ar1[6];
	 double r, V, C, C1, C2, C3, f, f1, f2, f3, p;
	 for(int i=0; i<3; i++){ Ar1[i]=r1[i]; Ar1[i+3]=v1[i];}
	 r = sqrt(Ar1[0]*Ar1[0] + Ar1[1]*Ar1[1] + Ar1[2]*Ar1[2]); // модуль в-ра r
  //  V = sqrt(Ar1[3]*Ar1[3] + Ar1[4]*Ar1[4] * Ar1[5]*Ar1[5]); // модуль в-ра V
  // возможно нужен поиск угла между этими векторами Альфа
  // находим компоненты и модули вектора кинетического момента C и в-ра Лапласа f
     C1 = Ar1[1]*Ar1[5] - Ar1[2]*Ar1[4];
	 C2 = Ar1[2]*Ar1[3] - Ar1[0]*Ar1[5];
     C3 = Ar1[0]*Ar1[4] - Ar1[1]*Ar1[3];
	 C = sqrt(C1*C1 + C2*C2 + C3*C3);
	 f1 = -mu*Ar1[0]/r + C3*Ar1[4] - C2*Ar1[5];
	 f2 = -mu*Ar1[1]/r + C1*Ar1[5] - C3*Ar1[3];
	 f3 = -mu*Ar1[2]/r + C2*Ar1[3] - C1*Ar1[4];
	 f = sqrt(f1*f1 + f2*f2 + f3*f3);
	 Ar2[1] = f/mu;                    // эксцентриситет е
	 p = (C*C)/mu;                     // фокальный параметр р
	 Ar2[0] = p/(1 - Ar2[1]*Ar2[1]);   // большая полуось орбиты a
	 Ar2[3] = acos(C3/C);              // наклонение i [0;pi]

  // находим омегуБ, омегуМ, и u в диапазоне [0;2pi] сравнивая син и кос
	 double AC, AS;
  // Ar2[5] = ОмегаБ
	 AS = C1/(C*sin(Ar2[3]));
	 AC = - C2/(C*sin(Ar2[3]));

	 Ar2[5] = atan2(AS,AC);
  //----------------
  // Ar2[4] = ОмегаМ
	 AS = (-f1*sin(Ar2[5]) + f2*cos(Ar2[5]))/(f*cos(Ar2[3]));
	 AC = (f1*cos(Ar2[5]) + f2*sin(Ar2[5]))/f;
	 Ar2[4] = atan2(AS,AC);
  //----------------
  // Ar2[2] = угол u
	 AS = (-Ar1[0]*sin(Ar2[5]) + Ar1[1]*cos(Ar2[5]))/(r*cos(Ar2[3]));
	 AC = (Ar1[0]*cos(Ar2[5]) + Ar1[1]*sin(Ar2[5]))/r;

	 Ar2[2] = atan2(AS,AC);
  }
//---------------------------------------------------------------------------

/*Процедура нахождения u (аргумента широты в радианах) в зависимости от времени в секундах (t=0 - перицентр)
Входные параметры:
		t - время в секундах от перицентра
		a - большая полуось орбиты [км]
		e - эксцентриситет орбиты
		omega - аргумерн широты перицентра [рад]
Выходные параметры:
		аргумент широты [рад]
Подключаемые модули:
		<math.h>
		"constants.h"
*/
double PoiskU(const double &t, const double &a, const double &e, const double &omega)
{
    double M,E,E_0,u;
	M = sqrt(mu/a/a/a)*t;
    E = 0;
	E_0 = 10;
	while (fabs(E-E_0)>1e-6)
	{
      E_0 = E;
	  E = e*sin(E_0) + M;
    }
	u = omega + 2*atan2(sqrt(1 + e)*tan(E/2), sqrt(1 - e));
    return u;
}

//--------------------------------------------------------------
/*Процедура нахождения времени(в сек от перицентра) по истинной аномалии и параметрам орбиты
Входные параметры:
		teta - истинная аномалия [рад]
		a - большая полуось орбиты [км]
		e - эксцентриситет орбиты
Выходные параметры:
		время в секундах от перицентра
Подключаемые модули:
		<math.h>
		"constants.h"
*/
double poisk_vrema(const double &teta, const double &a, const double &e)
{

  double M,E,E_0,t;
  E = atan2(sqrt(1-e*e)*sin(teta),e+cos(teta));
  while (E>=(2*M_PI))
	E-=2*M_PI;
  while (E<0)
	E+=2*M_PI;

  t = sqrt(a*a*a/mu)*(E - e*sin(E));
  return t;
}
//--------------------------------------------------------------
/*Процедура определения положения аппарата при невозмущенном кеплеровом движении
=============================================================================
Изменяемые параметры:
		  r0 - радиус-вектор
		  v0 - вектор скорости
		  t - интервал времени через сколько нада получить
				  новый вектор состояния в секундах
Используемые процедуры:
			CoordToElem
			ElemToCoord
			poisk_vrema
			PoiskU
*/
void Kepler (double r[], double v[], double t){
double	tt, Elem[6]={0};

//преодразуем вектор состояния в элементы орбиты
CoordToElem(r, v, Elem);
//находим время от перицентра на текущий вектор состояния
tt= poisk_vrema(Elem[2]-Elem[4], Elem[0], Elem[1]);
//Определяем аргумент широты для заданного времени
Elem[2]=PoiskU(tt+t,Elem[0],Elem[1],Elem[4]);
//переводим элементы орбиты в вектор состояния
ElemToCoord(Elem, r, v);

}
//--------------------------------------------------------------
/*Процедура определения положения аппарата при невозмущенном кеплеровом движении
=============================================================================
Изменяемые параметры:
			Elem[6] - массив элементов орбиты
				Elem[0] = a
				Elem[1] = e
				Elem[2] = u
				Elem[3] = i
				Elem[4] = omega
				Elem[5] = OMEGA
			t - момент времени в секундах от перицентра на который необходимо получить вектор
Используемые процедуры:
			ElemToCoord
			PoiskU
*/
void Kepler (double Elem[6], double t, double r[], double v[]){
//Определяем аргумент широты для заданного времени
Elem[2]=PoiskU(t,Elem[0],Elem[1],Elem[4]);
//переводим элементы орбиты в вектор состояния
ElemToCoord(Elem, r, v);

}