//---------------------------------------------------------------------------


#pragma hdrstop


#include "global.h"
#include "matrix.h" 
#include "report.h"
#include "constants.h"
#include "mathematic.h"
#include "integration.h"
#include "coordinate_system.h"

//---------------------------------------------------------------------------

#pragma package(smart_init)


/*запись НУ*/
void chi::integration::set_NU(double r[3], double v[3], double t){
	/*
	 *Параметры:
	 * 	r[3]	- радиус вектор КА [км]
	 *	v[3] 	- вектор скорости КА [км/с]
	 *	t	 	- момент времени на который приведен вектор состояния в формате
				  Юлианской даты (UTC)
	 */
for(int i=0; i<3; i++){
	r_nu[i]=r[i];
	v_nu[i]=v[i];
}
t_nu=t;
}
void chi::integration::set_NU(double rv[6],double t){
	/*
	 *Параметры:
	 *	кv[6] 	- вектор состояния КА [км, км/с]
	 *	t	 	- момент времени на который приведен вектор состояния в формате
				  Юлианской даты (UTC)
	 */
for(int i=0; i<3; i++){
	r_nu[i]=rv[i];
	v_nu[i]=rv[i+3];
}
t_nu=t;
}
/*запись параметров интегрирования*/
void chi::integration::setParametrs(double interval_, double step_){
	/*
	 *Параметры:
	 * 	interval_ 	- интервал прогноза в днях
	 *	step_   	- шаг выдачи информации в секундах
	 Примечание:
		- Если не требуется вывод промежуточных результатов то следует задавать
		  шаг равный интервалу
	 */
interval=interval_;
step=step_;
}

























	/* [ВЫЧИСЛЕНИЕ ПРАВЫХ ЧАСТЕЙ] */

/*вычисление правых частей ДУ*/
void chi::integration::rightPart(VECTOR &rv){
/*
	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *
	 *  Примечания:
	 *    – 

	 *  Допустимые значения параметров
	 *
	 *   calculeteMatrix:
	 *		0 - расчет только возмущающих ускорений,
	 *		1 - расчет только возмущающих ускорений и 
				матрицы частных производных
	 *
	 *   centralBody:
	 *		B_EARTH - 0 – Земля;
	 *		B_MOON  - 1 – Луна;
	 *		B_SUN   - 2 – Солнце;
	 */


/*обнуление векторов ускорений*/
for(int i=0; i<3; i++){
	a_central_field[i]=0;
	a_off_central_field[i]=0;
	a_celestial_bodies[i]=0;
	a_solar_radiation[i]=0;
	a_atmosphere[i]=0;
	a_traction[i]=0;
}


/*вычисление ускорений*/
switch(centralBody){
	case B_EARTH:	if(rp[0]) central_field(rv);      	//центральное поле
					if(rp[1]) off_central_field(rv);    //нецентральность 
					if(rp[2]) celestial_bodies(rv);     //небесные тела
					if(rp[3]) solar_radiation(rv);      //солнечное излучение 
					if(rp[4]) atmosphere(rv);           //атмосфера
					if(rp[5]) traction(rv);             //тяга ДУ
					break;


	case B_MOON: 	if(rp[0]) central_field_moon(rv);       //центральное поле
					if(rp[1]) off_central_field_moon(rv);   //нецентральность 
					if(rp[2]) celestial_bodies_moon(rv);    //небесные тела
					break;


	case B_SUN:     break;

}

/*суммирование расчитаных значений возмущающих ускорений*/
for (int i=0; i<3; i++){
	rv.f[i] = a_central_field[i]+
			  a_off_central_field[i]+
			  a_celestial_bodies[i]+
			  a_solar_radiation[i]+
			  a_atmosphere[i]+
			  a_traction[i];
}

/*расчет матрицы частных производных*/
if(calculeteMatrix){

	/*обнуление матрицы*/
	for(int i=0; i<6; i++)
		for(int j=0; j<6; j++)
			rv.dfdx[i][j]=0;
			
	/*задание единичных элементов*/
	rv.dfdx[0][3]=1;
	rv.dfdx[1][4]=1;
	rv.dfdx[2][5]=1;

	/*задание элементов матрицы из матрицы изохронных производных*/
	for(int i=0; i<3; i++)
		for(int j=0; j<3; j++)  
			rv.dfdx[i+3][j]	= df_central_field[i][j]+
							  df_off_central_field[i][j]+
							  df_celestial_bodies[i][j];

	matr_X_matr(rv.dfdx, rv.F, rv.F_);
}
}

/*вычисление возмущающего ускорения, обусловленного центральным
  гавитационным полем Земли и матрицы частных производных этого вектора*/
void chi::integration::central_field(VECTOR rv){
/*
	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *
	 *  Примечания:
	 *    – 

	 *  Допустимые значения параметров
	 *
	 *   calculeteMatrix:
	 *		0 - расчет только возмущающих ускорений,
	 *		1 - расчет только возмущающих ускорений и 
				матрицы частных производных
	 *

	 */

/*вычисление модуля радиус-вектора, второй и третей степени */
double R=norm(rv.r);
double R2=R*R;
double R3=R2*R;

/*вычисление возмущающего ускорения, обусловленного центральным
  гавитационным полем Земли*/
for (int k=0; k<3; k++)
	a_central_field[k] =  - mu*rv.r[k]/R3;

/*вычисление матрица частных производных вектора гравитационных возмущений 
  центрального тела по вектору положения*/
if(calculeteMatrix){  
	for(int i=0;i<3;i++){
		for(int j=0; j<3;j++)
			df_central_field[i][j]=rv.r[i]*rv.r[j]/R2;
	}
	for(int i=0; i<3; i++)  df_central_field[i][i]-=1./3.;
	for(int i=0; i<3;i++){
		for(int j=0; j<3; j++)
			df_central_field[i][j]*=3*mu/R3;
	}
}
}

/*вычисление возмущающего ускорения, обусловленного центральным
  гавитационным полем Луны и матрицы частных производных этого вектора*/
void chi::integration::central_field_moon(VECTOR rv){
/*
	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *
	 *  Примечания:
	 *    – 

	 *  Допустимые значения параметров
	 *
	 *   calculeteMatrix:
	 *		0 - расчет только возмущающих ускорений,
	 *		1 - расчет только возмущающих ускорений и 
				матрицы частных производных
	 *

	 */

/*вычисление модуля радиус-вектора, второй и третей степени */
double R=norm(rv.r);
double R2=R*R;
double R3=R2*R;

/*вычисление возмущающего ускорения, обусловленного центральным
  гавитационным полем Земли*/
for (int k=0; k<3; k++)
	a_central_field[k] =  - mum*rv.r[k]/R3;

/*вычисление матрицы частных производных вектора гравитационных возмущений 
  центрального тела по вектору положения*/
if(calculeteMatrix){  
	for(int i=0;i<3;i++){
		for(int j=0; j<3;j++)
			df_central_field[i][j]=rv.r[i]*rv.r[j]/R2;
	}
	for(int i=0; i<3; i++)  df_central_field[i][i]-=1./3.;
	for(int i=0; i<3;i++){
		for(int j=0; j<3; j++)
			df_central_field[i][j]*=3*mum/R3;
	}
}
}

/*вычисление возмущающего ускорения обусловленного нецентральностью
  гравитационного поля Земли и матрицы частных производных этого вектора*/
void chi::integration::off_central_field(VECTOR rv){
/*
	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *
	 *  Примечания:
	 *    – 

	 *  Допустимые значения параметров
	 *
	 *   harmonicType:
	 *		C20 - 0 - вычисление по формулам второй зональной гармоники
	 *		C40 - 1 - вычисление по формулам четвертой зональной гармоники
	 *		H32	- 2 - вычисление разложения до порядка 32х32    
	 *
	 *   calculeteMatrix:
	 *		0 - расчет только возмущающих ускорений,
	 *		1 - расчет только возмущающих ускорений и 
				матрицы частных производных
	 *

	 */

double df[3]={0};

switch(harmonicType){
	case C20: off_central_field_C20(rv);
			  break;
	case C40: off_central_field_C40(rv);
			  break;
	case H32: off_central_field_32(rv, a_off_central_field);
			  /*вычисление матрицы частных производных вектора гравитационных 
				возмущений нецентральностьи гравитационного поля тела по 
				вектору положения*/
			  if(calculeteMatrix){
				  double delta=0.001;
				  VECTOR temp;  
				  for(int i=0; i<3; i++) {
					  temp=rv;
					  temp.r[i]+=delta;
					  off_central_field_32(rv, df);
					  for(int j=0; j<3; j++) df_off_central_field[i][j]=df[j];
					  temp=rv;
					  temp.r[i]-=delta;
					  off_central_field_32(rv, df);
					  for(int j=0; j<3; j++) df_off_central_field[i][j]-=df[j];
					  for(int j=0; j<3; j++) df_off_central_field[i][j]/=2*delta;
				  }

			  }
			  break;

}
}

/*вычисление возмущающего ускорения обусловленного нецентральностью
  гравитационного поля Луны и матрицы частных производных этого вектора*/
void chi::integration::off_central_field_moon(VECTOR rv){
/*
	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *
	 *  Примечания:
	 *    – 

	 *  Допустимые значения параметров
	 *
	 *   calculeteMatrix:
	 *		0 - расчет только возмущающих ускорений,
	 *		1 - расчет только возмущающих ускорений и 
	 *			матрицы частных производных
	 *

	 */

double df[3]={0};

off_central_field_75_moon(rv, df);
/*вычисление матрицы частных производных вектора гравитационных возмущений 
  нецентральностьи гравитационного поля тела по вектору положения*/
if(calculeteMatrix){
	double delta=0.001;
	VECTOR temp;  
	for(int i=0; i<3; i++) {
		  temp=rv;
		  temp.r[i]+=delta;
		  off_central_field_75_moon(rv, df);
		  for(int j=0; j<3; j++) df_off_central_field[i][j]=df[j];
		  temp=rv;
		  temp.r[i]-=delta;
		  off_central_field_32(rv, df);
		  for(int j=0; j<3; j++) df_off_central_field[i][j]-=df[j];
		  for(int j=0; j<3; j++) df_off_central_field[i][j]/=2*delta;
	}
}
}


/*вычисление возмущающего ускорения обусловленного нецентральностью
  гравитационного поля Земли(второй зональной гармоникой - С20)*/
void chi::integration::off_central_field_C20(VECTOR rv){
/*
	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *
	 *  Примечания:
	 *    – 
	 *  Допустимые значения параметров
	 *
	 *   calculeteMatrix:
	 *		0 - расчет только возмущающих ускорений,
	 *		1 - расчет только возмущающих ускорений и 
	 *			матрицы частных производных
	 *
	 * 	Используемые константы (CONSTBNO.h):
	 *		double R_Earth = 6378.136;       Экв. радиус Земли (км)
	 *		double b2      = 17599253992.788798202843556774502;
	 */

/*вычисление модуля радиус-вектора его квадрата и пятой степени*/
double R=norm(rv.r);
double R2=R*R;
double R5=R2*R2*R;
/*рассчитанный коэффициент*/
double b2=17599253992.788798202843556774502;

/*вычисление ускорения обусловленно второй зональной гармоники*/
a_off_central_field[0]=3*b2*rv.r[0]*(5*rv.r[2]*rv.r[2]/R2-1)/2/R5;
a_off_central_field[1]=3*b2*rv.r[1]*(5*rv.r[2]*rv.r[2]/R2-1)/2/R5;
a_off_central_field[2]=3*b2*rv.r[2]*(5*rv.r[2]*rv.r[2]/R2-3)/2/R5;

/*вычисление матрицы частных производных вектора гравитационных возмущений
  нецентральностьи гравитационного поля тела по вектору положения*/
if(calculeteMatrix){
	double e[3];
	for(int i=0; i<3; i++) e[i]=rv.r[i]/R;
	double H=15*J20*mu*R_Earth*R_Earth/2/R5;
	double ez2=e[2]*e[2];
	df_off_central_field[0][0]=H*(e[0]*e[0]*(7*ez2-1)-(ez2-0.2));
	df_off_central_field[0][1]=H*(e[0]*e[1]*(7*ez2-1));
	df_off_central_field[0][2]=H*(e[0]*e[2]*(7*ez2-3));

	df_off_central_field[1][0]=H*(e[0]*e[1]*(7*ez2-1));
	df_off_central_field[1][1]=H*(e[1]*e[1]*(7*ez2-1)-(ez2-0.2));
	df_off_central_field[1][2]=H*(e[1]*e[2]*(7*ez2-3));

	df_off_central_field[2][0]=H*(e[0]*e[2]*(7*ez2-3));
	df_off_central_field[2][1]=H*(e[1]*e[2]*(7*ez2-3));
	df_off_central_field[2][2]=H*(ez2*(7*ez2-6)+3./5.);
}



}
	
/*вычисление возмущающего ускорения обусловленного нецентральностью
  гравитационного поля Земли(второй зональной гармоникой - С40)*/
 void chi::integration::off_central_field_C40(VECTOR rv){
 /*

	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *
	 *  Примечания:
	 *    – 
	 *
	 * 	Используемые константы (CONSTBNO.h):
	 *		double R_Earth = 6378.136;       Экв. радиус Земли (км)
	 *		double b0 = 3.9860044e5; геоцентрическая константа гравитационного поля Земли с учетом атмосферы
	 * 		double b2 =-1.755513e10; констатнта для учета второй зональной гармоники
	 *		double b4 = 1.564027e15; констатнта для учета четвернтой зональной гармоники
	 *
*/

static double b0; /*геоцентрическая константа гравитационного поля Земли с учетом атмосферы*/
static double b2; /*констатнта для учета второй зональной гармоники*/
static double b4; /*констатнта для учета четвернтой зональной гармоники*/

static double R;  /*модуль радиус-вектора КА на текущей итерации вычисления коэффициентов					*/
static double R3; /*третья степень модуля радиус-вектора КА на текущей итерации вычисления коэффициентов  */
static double R5; /*пятая степень модуля радиус-вектора КА на текущей итерации вычисления коэффициентов   */
static double R7; /*седьмая степень модуля радиус-вектора КА на текущей итерации вычисления коэффициентов   */

static double S;  /*Направляющий косинус по оси z*/
static double S2; /*Вторая степень направляющего косинуса по оси z*/
static double S4; /*Четвертая степень направляющего косинуса по оси z*/

static double q;  /*геопотенциал*/
static double dq; /*поправка геопотенциала по оси z*/

/*присвоение значений геоцентрических констант*/
b0 = 3.9860044e5;
b2 =-1.755513e10;
b4 = 1.564027e15;

/*вычисление модуля радиус-вектора КА и его 3, 5, 7 степеней*/
R = norm(rv.r);
if(R<R_Earth) report(100);
R3 = R*R*R;
R5 = R3*R*R;
R7 = R5*R*R;

/*вычисление направляющего косинуса по оси z и его 2 и 4 степеней*/
S  = rv.r[2]/R;
S2 = S*S;
S4 = S2*S2;

/*вычисление геопотенциала*/
dq = 3*b2/R5 + 5*b4*(7*S2 - 3)/(2*R7);
q  = -b0/R3 - 3*b2*(5*S2 - 1)/(2*R5) - 15*b4*(21*S4 - 14*S2 + 1)/(8*R7);

/*вычисление ускорения*/
a_off_central_field[0] =  rv.r[0]*q;
a_off_central_field[1] =  rv.r[1]*q;
a_off_central_field[2] =  rv.r[2]*(q + dq);

 }


/*вычисление возмущающего ускорения обусловленного нецентральностью
  гравитационного поля Земли с учетом гармоник до 32х32 и матрицы частных
  производных этого вектора*/
void chi::integration::off_central_field_32(VECTOR rv, double df[3]){
/*

	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *   df - ускорение обусловленного нецентральностью гравитационного
	 *  Примечания:
	 *    – 
	 *
	 *  Допустимые значения параметров
	 *
	 *   harmonicOrder: диапазон [2,32] четное
	 *		
	 *
	 * 	Используемые константы (CONSTBNO.h):
	 *		double R_Moon       Экв. радиус Луны (км)
	 *
*/

int nm;
double U[34][34]={0};
double V[34][34]={0};
double dU[33][33][3]={0};
double dV[33][33][3]={0};
double a_G_gr[3];
double r[3]={0};
double R=norm(rv.r);
double R2=R*R;
double t=t_nu+rv.t/86400.;
double RZi;


/*определяем порядок гармоник*/
if(harmonicOrder<=32 && harmonicOrder>=2) nm=harmonicOrder+1;
else nm=33;

// переход в Гринвича
GEItoGEO(rv.r,t,r);

/*определяются нулевые элементы*/
U[0][0] = 1./R;
V[0][0] = 0.;

/*Диагональные элементы*/
for (int i=0; i<nm; i++){
	U[i+1][i+1] = (2*i + 1)*(r[0]*U[i][i] - r[1]*V[i][i])/R2;
	V[i+1][i+1] = (2*i + 1)*(r[0]*V[i][i] + r[1]*U[i][i])/R2;
}

/*Остальные Элементы*/
for (int i=0; i<nm; i++){
	for (int j=0; j<nm; j++){
		if (j>i){
			U[i][j] = 0.;
			V[i][j] = 0.;
		}
		else{
			if (i==0){
				U[i+1][j] = (2*i + 1)*r[2]*U[i][j]/(i - j + 1)/R2;
				V[i+1][j] = (2*i + 1)*r[2]*V[i][j]/(i - j + 1)/R2;
			}
			else{
				U[i+1][j] = ((2*i + 1)*r[2]*U[i][j] - (i + j)*U[i-1][j])/(i - j + 1)/R2;
				V[i+1][j] = ((2*i + 1)*r[2]*V[i][j] - (i + j)*V[i-1][j])/(i - j + 1)/R2;
			}
		}
	}
}
/*вычисление производных сферических функций*/
for (int i=0; i<nm; i++){
	/*Нулевой элемент в i-ой строке производной сферических функций по Х*/
	dU[i][0][0] = -U[i+1][1];
	dV[i][0][0] = 0.;
	/*Нулевой элемент в i-ой строке производной сферических функций по Y*/
	dU[i][0][1] = -V[i+1][1];
	dV[i][0][1] = 0.;
	/*Нулевой элемент в i-ой строке производной сферических функций по Z*/
	dU[i][0][2] = -(i + 1.)*U[i+1][0];
	dV[i][0][2] = -(i + 1.)*V[i+1][0];
	for (int j=1; j<nm; j++){
		/*Остальные элементы производной сферических функций по Х*/
		dU[i][j][0] = -0.5*U[i+1][j+1] + 0.5*(i - j + 2)*(i - j + 1)*U[i+1][j-1];
		dV[i][j][0] = -0.5*V[i+1][j+1] + 0.5*(i - j + 2)*(i - j + 1)*V[i+1][j-1];
		/*Остальные элементы производной сферических функций по У*/
		dU[i][j][1] = -0.5*V[i+1][j+1] - 0.5*(i - j + 2)*(i - j + 1)*V[i+1][j-1];
		dV[i][j][1] =  0.5*U[i+1][j+1] + 0.5*(i - j + 2)*(i - j + 1)*U[i+1][j-1];
		/*Остальные элементы производной сферических функций по Z*/
		dU[i][j][2] = -(i - j + 1.)*U[i+1][j];
		dV[i][j][2] = -(i - j + 1.)*V[i+1][j];
	}
}

/*вычисление ускорения*/
for (int k=0; k<3; k++) {
	/*возводение радиуса Земли в нулевую степень*/
	RZi=1;
	/*обнуление текущей проекции вектора ускорений*/
	a_G_gr[k]=0;
	for (int i=0; i<nm; i++){
		for (int j=0; j<nm; j++){
			/*вычисление текущей проекции вектора ускорения*/
			a_G_gr[k] += mu*RZi*(Cnn[i][j]*dU[i][j][k] + Snn[i][j]*dV[i][j][k]);
		}
		/*возводение радиуса Земли в следующую степень степень*/
		RZi*=R_Earth;
	}

}
//переход обратно в 2ЭСК
GEOtoGEI(a_G_gr,t,df);
}

/*вычисление возмущающего ускорения обусловленного нецентральностью
  гравитационного поля Луны с учетом гармоник до 75х75 и матрицы частных
  производных этого вектора*/
void chi::integration::off_central_field_75_moon(VECTOR rv, double df[3]){
/*

	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *   df - ускорение обусловленного нецентральностью гравитационного
	 *  Примечания:
	 *    – 
	 *
	 *  Допустимые значения параметров
	 *
	 *   harmonicOrder: диапазон [2,75] 
	 *		
	 *
	 * 	Используемые константы (CONSTBNO.h):
	 *		double R_Moon       Экв. радиус Луны (км)
	 *
*/
int nm;
double U[34][34]={0};
double V[34][34]={0};
double dU[33][33][3]={0};
double dV[33][33][3]={0};
double r[3]={0};
double v[3]={0};
double df_G_gr[3]={0};
double R=norm(rv.r);        /*вычисление модуля радиус-вектора*/
double R2=R*R;              /*вычисление квадрата модуля радиус-вектора */
double t=t_nu+rv.t/86400.;  /*формирование времени в формате UTC*/
double RZi;
double zero[3]={0};


/*определяем порядок гармоник*/
if(harmonicOrder<=32 && harmonicOrder>=2) nm=harmonicOrder+1;
else nm=33;

/*Перевод вектора состояния в Селенографическую СК*/
SCtoSG(rv.r, rv.v, t,r, v);

/*определяются нулевые элементы*/
U[0][0] = 1./R;
V[0][0] = 0.;

/*Диагональные элементы*/
for (int i=0; i<nm; i++){
	U[i+1][i+1] = (2*i + 1)*(r[0]*U[i][i] - r[1]*V[i][i])/R2;
	V[i+1][i+1] = (2*i + 1)*(r[0]*V[i][i] + r[1]*U[i][i])/R2;
}

/*Остальные Элементы*/
for (int i=0; i<nm; i++){
	for (int j=0; j<nm; j++){
		if (j>i){
			U[i][j] = 0.;
			V[i][j] = 0.;
		}
		else{
			if (i==0){
				U[i+1][j] = (2*i + 1)*r[2]*U[i][j]/(i - j + 1)/R2;
				V[i+1][j] = (2*i + 1)*r[2]*V[i][j]/(i - j + 1)/R2;
			}
			else{
				U[i+1][j] = ((2*i + 1)*r[2]*U[i][j] - (i + j)*U[i-1][j])/(i - j + 1)/R2;
				V[i+1][j] = ((2*i + 1)*r[2]*V[i][j] - (i + j)*V[i-1][j])/(i - j + 1)/R2;
			}
		}
	}
}
/*вычисление производных сферических функций*/
for (int i=0; i<nm; i++){
	/*Нулевой элемент в i-ой строке производной сферических функций по Х*/
	dU[i][0][0] = -U[i+1][1];
	dV[i][0][0] = 0.;
	/*Нулевой элемент в i-ой строке производной сферических функций по Y*/
	dU[i][0][1] = -V[i+1][1];
	dV[i][0][1] = 0.;
	/*Нулевой элемент в i-ой строке производной сферических функций по Z*/
	dU[i][0][2] = -(i + 1.)*U[i+1][0];
	dV[i][0][2] = -(i + 1.)*V[i+1][0];
	for (int j=1; j<nm; j++){
		/*Остальные элементы производной сферических функций по Х*/
		dU[i][j][0] = -0.5*U[i+1][j+1] + 0.5*(i - j + 2)*(i - j + 1)*U[i+1][j-1];
		dV[i][j][0] = -0.5*V[i+1][j+1] + 0.5*(i - j + 2)*(i - j + 1)*V[i+1][j-1];
		/*Остальные элементы производной сферических функций по У*/
		dU[i][j][1] = -0.5*V[i+1][j+1] - 0.5*(i - j + 2)*(i - j + 1)*V[i+1][j-1];
		dV[i][j][1] =  0.5*U[i+1][j+1] + 0.5*(i - j + 2)*(i - j + 1)*U[i+1][j-1];
		/*Остальные элементы производной сферических функций по Z*/
		dU[i][j][2] = -(i - j + 1.)*U[i+1][j];
		dV[i][j][2] = -(i - j + 1.)*V[i+1][j];
	}
}

/*вычисление ускорения*/
for (int k=0; k<3; k++) {
	/*возводение радиуса Земли в нулевую степень*/
	RZi=1;
	/*обнуление текущей проекции вектора ускорений*/
	df_G_gr[k]=0;
	for (int i=0; i<nm; i++){
		for (int j=0; j<nm; j++){
			/*вычисление текущей проекции вектора ускорения*/
			df_G_gr[k] += mu*RZi*(Cnn[i][j]*dU[i][j][k] + Snn[i][j]*dV[i][j][k]);
		}
		/*возводение радиуса Земли в следующую степень степень*/
		RZi*=R_Moon;
	}

}
//переход обратно в Селеноцентрическую СК
SGtoSC(df_G_gr, zero, t, df, zero);
}

/*вычисление ускорения обусловленных действием небесных тел
  (реализация для 10 небесных тел, центральное тело Земля) и матрицы частных
  производных этого вектора*/
void chi::integration::celestial_bodies(VECTOR rv){
/*
	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *
	 *  Примечания:
	 *    – 
	 *  Допустимые значения параметров
	 *   planet[j] -  признак уччета планет
	 *   calculeteMatrix:
	 *		0 - расчет только возмущающих ускорений,
	 *		1 - расчет только возмущающих ускорений и 
	 *			матрицы частных производных
	 *

	 */

unsigned centerBody=dph::B_EARTH; 	/*определяем центральное тело Земля - 3 */
unsigned targetBody;              	/*текущее небесное тело*/
double t=t_nu+rv.t/86400.;  		/*формирование времени в формате UTC*/
double r_planet[3];
double r_ka_planet[3];
double r[3];
double R_planet;
double R_planet3;
double R_ka_planet;
double R_ka_planet2;
double R_ka_planet3;
double a_planet[11][3];
double df_planet[11][3][3];


for(int j=0; j<11; j++){
	if(planet[j]){
		/*определение текущего небесного тела*/
		targetBody=j+1;
		/*исключаем случай центрального небесного тела*/ 
		if(targetBody==centerBody) {j++; targetBody++;}  
		/*определение координат текущего небесного тела*/	
		de405.calculateR(targetBody, centerBody, t, r_planet);
		/*определение расстояния до текущего небесного тела от центрального*/
		R_planet=norm(r_planet); 
		/*определение расстояния до текущего небесного тела от центрального*/
		R_planet3=R_planet*R_planet*R_planet;  
		/*определение вектора с аппарата на текущее небесное тело*/
		for(int i=0; i<3; i++) 
			r_ka_planet[i]=r_planet[i]-rv.r[i];
		/*определение расстояния от аппарата до текущего небесного тела	*/
		R_ka_planet=norm(r_ka_planet); 
		/*определение квадрата расстояния от аппарата до текущего небесного тела*/
		R_ka_planet2=R_ka_planet*R_ka_planet;   
		/*определение куба расстояния от аппарата до текущего небесного тела*/
		R_ka_planet3=R_ka_planet2*R_ka_planet;    
		//определяем масив векторов ускорений обусловленных влиянием небесных тел
		for(int i=0; i<3; i++)
			a_planet[j][i]=mu_planet[j]*(r_ka_planet[i]/R_ka_planet3-r_planet[i]/R_planet3);

		/*вычисление матрицы частных производных вектора гравитационных 
		  возмущений небесных тел по вектору положения*/
		if(calculeteMatrix){
			
			/*вычисление вектора планета-КА*/
			for(int i=0; i<3; i++) r[i]=-r_ka_planet[i];
			/*вычисление первого слогаемого матрицы*/
			for(int i=0;i<3;i++){
				for(int k=0; k<3;k++)
					df_planet[j][i][k]=r[i]*r[k]/R_ka_planet2;
			}
			/*вычисление второго слогаемого матрицы*/
			for(int i=0; i<3; i++)  df_planet[j][i][i]-=1./3.;
			/*домноежение элементов матрицы на коэффициент*/
			for(int i=0; i<3;i++){
				for(int k=0; k<3; k++)
					df_planet[j][i][k]*=3*mu_planet[j]/R_ka_planet3;
			}
		}
	}
}

/*определяем результирующее ускорение от всех небесных тел кроме центрального*/
for(int i=0; i<3; i++){
	a_celestial_bodies[i]=0;
	for(int j=0; j<11; j++)
		a_celestial_bodies[i]+=a_planet[j][i];
}

/*вычисление матрицы частных производных вектора гравитационных 
  возмущений небесных тел по вектору положения*/
if(calculeteMatrix){
	for(int i=0; i<3; i++){
		for(int j=0; j<3; j++){
			df_celestial_bodies[i][j]=0;
			for(int k=0; k<11; k++){
				df_celestial_bodies[i][j]+=df_planet[k][i][j];
			}
		}
	}
}
}

/*вычисление ускорения обусловленных действием небесных тел
  (реализация для 10 небесных тел, центральное тело Луна) и матрицы частных
  производных этого вектора*/
void chi::integration::celestial_bodies_moon(VECTOR rv){
/*
	 *  Параметры:
	 *   rv – структура типа VECTOR (вектор состояния и матрицы)
	 *
	 *  Примечания:
	 *    – 
	 *  Допустимые значения параметров
	 *   planet[j] -  признак уччета планет
	 *   calculeteMatrix:
	 *		0 - расчет только возмущающих ускорений,
	 *		1 - расчет только возмущающих ускорений и 
	 *			матрицы частных производных
	 *

	 */
unsigned centerBody=dph::B_MOON; 	/*определяем центральное тело Земля - 3 */
unsigned targetBody;              	/*текущее небесное тело*/
double t=t_nu+rv.t/86400.;  		/*формирование времени в формате UTC*/
double r_planet[3];
double r_ka_planet[3];
double r[3];
double R_planet;
double R_planet3;
double R_ka_planet;
double R_ka_planet2;
double R_ka_planet3;
double a_planet[11][3];
double df_planet[11][3][3];


for(int j=0; j<11; j++){
	if(planet[j]){
		/*определение текущего небесного тела*/
		targetBody=j+1;
		/*исключаем случай центрального небесного тела*/ 
		if(targetBody==centerBody) {j++; targetBody++;}  
		/*определение координат текущего небесного тела*/	
		de405.calculateR(targetBody, centerBody, t, r_planet);
		/*определение расстояния до текущего небесного тела от центрального*/
		R_planet=norm(r_planet); 
		/*определение расстояния до текущего небесного тела от центрального*/
		R_planet3=R_planet*R_planet*R_planet;  
		/*определение вектора с аппарата на текущее небесное тело*/
		for(int i=0; i<3; i++) 
			r_ka_planet[i]=r_planet[i]-rv.r[i];
		/*определение расстояния от аппарата до текущего небесного тела	*/
		R_ka_planet=norm(r_ka_planet); 
		/*определение квадрата расстояния от аппарата до текущего небесного тела*/
		R_ka_planet2=R_ka_planet*R_ka_planet;   
		/*определение куба расстояния от аппарата до текущего небесного тела*/
		R_ka_planet3=R_ka_planet2*R_ka_planet;    
		//определяем масив векторов ускорений обусловленных влиянием небесных тел
		for(int i=0; i<3; i++)
			a_planet[j][i]=mu_planet[j]*(r_ka_planet[i]/R_ka_planet3-r_planet[i]/R_planet3);

		/*вычисление матрицы частных производных вектора гравитационных 
		  возмущений небесных тел по вектору положения*/
		if(calculeteMatrix){
			
			/*вычисление вектора планета-КА*/
			for(int i=0; i<3; i++) r[i]=-r_ka_planet[i];
			/*вычисление первого слогаемого матрицы*/
			for(int i=0;i<3;i++){
				for(int k=0; k<3;k++)
					df_planet[j][i][k]=r[i]*r[k]/R_ka_planet2;
			}
			/*вычисление второго слогаемого матрицы*/
			for(int i=0; i<3; i++)  df_planet[j][i][i]-=1./3.;
			/*домноежение элементов матрицы на коэффициент*/
			for(int i=0; i<3;i++){
				for(int k=0; k<3; k++)
					df_planet[j][i][k]*=3*mu_planet[j]/R_ka_planet3;
			}
		}
	}
}

/*определяем результирующее ускорение от всех небесных тел кроме центрального*/
for(int i=0; i<3; i++){
	a_celestial_bodies[i]=0;
	for(int j=0; j<11; j++)
		a_celestial_bodies[i]+=a_planet[j][i];
}

/*вычисление матрицы частных производных вектора гравитационных 
  возмущений небесных тел по вектору положения*/
if(calculeteMatrix){
	for(int i=0; i<3; i++){
		for(int j=0; j<3; j++){
			df_celestial_bodies[i][j]=0;
			for(int k=0; k<11; k++){
				df_celestial_bodies[i][j]+=df_planet[k][i][j];
			}
		}
	}
}
}

	/*вычисление ускорения обусловленного действием солнечного излучения и
	  матрицы частных производных этого вектора*/
	void chi::integration::solar_radiation(VECTOR rv){
	}

	/*вычисление ускорения обусловленного воздействием силы сопротивления
	  атмосферы в соответствии с ГОСТ Р 25645.166-2004*/
	void chi::integration::atmosphere(VECTOR rv){
	}

	/*вычисление ускорения обусловленного воздействием силы сопротивления
	  атмосферы в соответствии с ГОСТ Р 25645.166-2004*/
	void chi::integration::atmosphereGOST2004(VECTOR rv){
	}

	/*вычисление ускорения обусловленного работой двигательной установки*/
	void chi::integration::traction(VECTOR rv){
    }
